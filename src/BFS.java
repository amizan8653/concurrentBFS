/**
 * Assignment #3: 8 puzzle
 * March 15, 2013
 * BFS.java
 * Programmed by Ali mizan
 * 
 * Approach of this program: generate a node that contains the solution. afterwards,
 * use the BFS algorithm to generate the tree of all possible permutations of
 * unsolved puzzle positions. As each puzzle position is being generated, update
 * a hashMap that maps the scrambled permutation to the corresponding level on the graph.
 * Only the minimum level is stored. the level on the graph represents the number 
 * of moves needed to go from solved position to that scrambled position, which of course
 * is the same number of moves needed to go from that scrambled position to the solved one.
 * After HashMap created, you scan in the test cases and look it up on the HashMap
 */

import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.util.*;

public class BFS{
	
	private static class puzzlePosition{
		int hashValue; //this will store the board itself
		int zeroPosition = 0; //store where the 0 currently is on the board
		int level; //this is the level of the node in the graph / number of moves
		
		//this variable keeps track of what the previous slide was.
		//purpose of this is to avoid doing a redundant slide back
		// 10 = the root node, which wasn't generated by a slide
		// 0 = up, 1 = down, 2 = left, 3 = right
		int generatingSlide; 
		
		//will be array of size 4 pointing to 4 possible children.
		puzzlePosition [] children;
		
		
		//a constucutor for the very first root node, which is the solution of the puzzle
		public puzzlePosition(){
			level = 0; //only the first root can have level = 0. all others will be positive integer
			generatingSlide = 10; //10 just for first node. means no slide generated it
			hashValue = 123456780; //hashValue of solved position for the root.
			zeroPosition = 8; //zero is the 8th position (last position) of the hashValue integer
			children = new puzzlePosition[4];// each node will have a default of 4 possible children
											//even though the root will only have 2
		}
		
		//a constructor for generating the children
		public puzzlePosition(puzzlePosition root, int direction){
			int slidingTile = 0;   //this is the digit out of the hashCode you want to slide
			int timesToDivide = 0; //num of times you divide hashCode by 10 
								   // before you can %10 to get sliding tile
			
			level = root.level + 1; //increment the number of moves it takes to solve
			children = new puzzlePosition[4];// each node will have a default of 4 possible children
			
			// direction: 0 = tile up, 1 = tile down, 2 = tile left, 3 = tile right	
			// x is the row, y is the column
			zeroPosition = root.zeroPosition; //copy over the zeroPosition
			
			//copy the board from the root over exactly
			this.hashValue = root.hashValue;
			
			//save the slide that generated this permutation
			generatingSlide = direction; 
			
			//set the partent's child to point to this newly created node
			root.children[generatingSlide] = this;
			
			//switch will change the board based on direction you're dragging the tile
			switch(direction){
				case 0:
					//you want the tile to go up
					//board[x][y] = board[x+1][y];
					//board[x+1][y] = 0;
					//this is the times you should divide to get the sliding tile board[x][y]
					timesToDivide = (9 - zeroPosition - 1) -3; 
					//go ahead and divide
					slidingTile = divide(hashValue, timesToDivide);
					//now mod to get the actual value
					slidingTile %= 10;
					
					//perform the slide. first set the new 0:
					hashValue -= slidingTile * powersOfTen(timesToDivide);
					
					//now replace the old 0 with the new tile
					hashValue += slidingTile * powersOfTen(timesToDivide+3);
									
					zeroPosition += 3; //if tile went up, zero went down 1 row, increasing 3 in position
					break;
				case 1: 
					//you want the tile to go down
					//board[x][y] = board[x-1][y];
					//board[x-1][y] = 0;
					//this is the times you should divide to get the sliding tile board[x - 1][y]
					timesToDivide = (9 - zeroPosition - 1) + 3; //used to pull nonzero tile to slide
					//go ahead and divide
					slidingTile = divide(hashValue, timesToDivide);
					//now mod to get the actual value
					slidingTile %= 10;
					
					//perform the slide. first set the new 0:
					hashValue -= slidingTile * powersOfTen(timesToDivide);
					
					//now replace the old 0 with the new tile
					hashValue += slidingTile * powersOfTen(timesToDivide-3);
					
					zeroPosition -= 3; //if the tile went down, zero went up 1 row, decreasing 3 in position
					break;
				case 2: 
					//you want the tile to go left
					//board[x][y] = board[x][y+1];
					//board[x][y+1] = 0;
					//this is the times you should divide to get the sliding tile board[x][y]
					timesToDivide = (9 - zeroPosition - 1) -1; 
					//go ahead and divide
					slidingTile = divide(hashValue, timesToDivide);
					//now mod to get the actual value
					slidingTile %= 10;
					
					//perform the slide. first set the new 0:
					hashValue -= slidingTile * powersOfTen(timesToDivide);
					
					//now replace the old 0 with the new tile
					hashValue += slidingTile * powersOfTen(timesToDivide+1);
									
					zeroPosition += 1; // if tile went left, 0 went right 1, increasing in position
					break;
				case 3: 
					//you want the tile to go right
					//board[x][y] = board[x][y-1];
					//board[x][y-1] = 0;
					//this is the times you should divide to get the sliding tile board[x][y]
					timesToDivide = (9 - zeroPosition - 1) + 1; 
					//go ahead and divide
					slidingTile = divide(hashValue, timesToDivide);
					//now mod to get the actual value
					slidingTile %= 10;
					
					//perform the slide. first set the new 0:
					hashValue -= slidingTile * powersOfTen(timesToDivide);
					
					//now replace the old 0 with the new tile
					hashValue += slidingTile * powersOfTen(timesToDivide-1);
									
					zeroPosition -= 1; //if tile went right, 0 went left 1, decreasing in position
					break;
			}
			

		}
		
		

		//return the hash
		public int getHash(){
			return hashValue;
		}
		
		
	}
	//create the queue data structure and all it's functions. this is a queue of puzzlePositions
	private static class Queue {

		  private int front; //variable that will keep track of the front of the queue

		  private int end; //variable that will keep track of the rear of the queue

		  private int totalItems; //keep track of the number of items currently in queue
		  
		  private int capacity; //queue capapcity, or size of the array

		  private puzzlePosition[] QueueArray; // array of references to the puzzlePositions

		  //constructor
		  public Queue(int s) {
			capacity = s;
			front = 0;
			end = -1;
		    QueueArray = new puzzlePosition[capacity];    
		    totalItems = 0;
		  }
		  

		  //   put item at end of a queue
		  public void insert(puzzlePosition j) {
		    if (end == capacity - 1) // deal with wraparound
		    	end = -1;
		    end++;				// increment rear
		    QueueArray[end] = j; // insert
		    totalItems++; 
		  }

		  //   take item from front of queue
		  public puzzlePosition remove() {
			  puzzlePosition temp = QueueArray[front++]; // get value and incr front
		    if (front == capacity) // deal with wraparound
		      front = 0;
		    totalItems--; // one less item
		    return temp; //return item you're removing
		  }


		  public boolean isEmpty() {
		    return (totalItems == 0);
		  }

	}
	
	//this function divides a number by 10 a certain number of times and returns the new value
	public static int divide(int value, int timesToDivide){
		for (int i = 0; i < timesToDivide; i++){
			value = value / 10;
		}
		return value;
	}
	
	
	public static void main (String [] args){
		long startTime = System.currentTimeMillis();
		int numOfMoves = 0;
		File file = new File("Input.in");
		Scanner screenReader;
		try {
			screenReader = new Scanner(file);
			PrintWriter out = new PrintWriter("outputResults.txt");
		
			int numOfCases = screenReader.nextInt(); //read in number of cases
			
			puzzlePosition root = new puzzlePosition(); //create the root of our graph.
			//this is the Queue used by the BFS
			Queue myQueue = new Queue(50000);
			
	
			//create the hashMap for pulling values for test cases
			HashMap <Integer, Integer> directory = new HashMap<Integer, Integer>();
	
			graphCreation(root, myQueue, directory); //create the graph itself containing
								//every possible unsolved permutation
			
			
			//this loop will execute once per test case
			for (int i = 0; i < numOfCases; i++){
				
				
				int puzzleHash = 0; //will represent the input board
				
					for (int k = 0; k < 3; k++){
						for (int j = 0; j < 3; j++){
							puzzleHash = puzzleHash +  powersOfTen(9- ((k*3) + j + 1)) * screenReader.nextInt();
						}
					}
	
				numOfMoves = directory.get(puzzleHash);
				out.println(numOfMoves);
			
				
			}
			long endTime = System.currentTimeMillis();
	        out.println("It took " + (endTime - startTime) + " milliseconds");
	        out.close();
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} //read in keyboard input
		
	}
	
	
	//Math.pow returns kinda slow, so I'll use this instead, since I'm only using base 10
	static int powersOfTen(int power){
		if(power == 0)
			return 1;
		else{
			int answer = 1;
			for(int i = 0; i < power; i++){
				answer *=10;
			}
			return answer;
		}
		
	}

	
	//creates a graph using BFS algorithm. stores level in hashMap
	static void graphCreation(puzzlePosition root, Queue myQueue, HashMap <Integer, Integer> directory){
		
		//this is a temporary variable used to point to puzzle positions
		//that will get dequeued.
		puzzlePosition t; 
						
		//this HashSet will hold the hashes that represent each
		//and every vertex. each vertex has a unique hashValue
		HashSet<Integer> AlreadyCreated = new HashSet<Integer>();
		
		//store the hash into the hashSet
		//AlreadyCreated.add(root.getHash()); 
		
		//insert the root into the queue
		myQueue.insert(root);
		//Map of the root
		directory.put(123456780, 0);
		
		//while the queue is not empty
		while(myQueue.isEmpty() == false){
			t = myQueue.remove();
			
			
			//generate adjacent verticies, check if they already exist
			//if they don't then enqueue them into the graph AND add hashVal to set
			//For new puzzlePosition constructor: 
			// direction: 0 = tile up, 1 = tile down, 2 = tile left, 3 = tile right	
			
			//generate the vertex for tile going up:
			//first check to see if it's possible to go up
			//and also make sure it wasn't a downslide that generated t, 
			//otherwise you're just going backwards
			if(t.zeroPosition <=5 && t.generatingSlide != 1){
				//a vertex for tile sliding up can be made
				puzzlePosition u = new puzzlePosition(t, 0);
				
				//if statement executes if hashMap doesn't already contain value
				if( AlreadyCreated.contains(u.getHash()) == false){
					AlreadyCreated.add(u.getHash()); //add to hashSet
					myQueue.insert(u); //go ahead and enqueue this possible solution
					directory.put(u.hashValue, u.level);//update the HashMap
				}
			} //exit case for tile going up
			
			
			//generate the vertex for tile going down:
			//first check to see if it's possible to go down
			//and also make sure it wasn't an upslide that generated t, 
			//otherwise you're just going backwards
			if(t.zeroPosition >2 && t.generatingSlide != 0){
				//a vertex for tile sliding down can be made
				puzzlePosition u = new puzzlePosition(t, 1);
				
				//if statement executes if hashMap doesn't already contain value
				if( AlreadyCreated.contains(u.getHash()) == false){
					//out.printf("Add to Queue\n");
					AlreadyCreated.add(u.getHash()); //add to hashSet
					myQueue.insert(u); //go ahead and enqueue this possible solution
					directory.put(u.hashValue, u.level);//update the HashMap
				}
			} //exit case for tile going down
			
			//generate the vertex for tile going left:
			if( (t.zeroPosition %3) != 2 && t.generatingSlide != 3){
				//a vertex for tile sliding to the left can be made
				puzzlePosition u = new puzzlePosition(t, 2);
				
				//if statement executes if hashSet doesn't already contain value
				if( AlreadyCreated.contains(u.getHash()) == false){
					//out.printf("Add to Queue\n");
					AlreadyCreated.add(u.getHash()); //add to hashSet
					myQueue.insert(u); //go ahead and enqueue this possible solution
					directory.put(u.hashValue, u.level);//update the HashMap
				}
			} //exit case for tile going left
			
			//generate the vertex for tile going Right:
			if( (t.zeroPosition %3) != 0 && t.generatingSlide != 2){
				//a vertex for tile sliding to the right can be made
				puzzlePosition u = new puzzlePosition(t, 3);
				
				//if statement executes if hashMap doesn't already contain value
				if( AlreadyCreated.contains(u.getHash()) == false){
					//out.printf("Add to Queue. size of queue: %d\n", myQueue.size());
					AlreadyCreated.add(u.getHash()); //add to hashSet
					myQueue.insert(u); //go ahead and enqueue this possible solution
					directory.put(u.hashValue, u.level); //update the HashMap
				}
			} //exit case for tile going Right
			
			
		} //exit while
		
	}

		
}
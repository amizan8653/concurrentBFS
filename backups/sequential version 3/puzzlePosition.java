public class puzzlePosition{
		int hashValue; //this will store the board itself
		int zeroPosition = 0; //store where the 0 currently is on the board
		int level; //this is the level of the node in the graph / number of moves
		
		//this variable keeps track of what the previous slide was.
		//purpose of this is to avoid doing a redundant slide back
		// 10 = the root node, which wasn't generated by a slide
		// 0 = up, 1 = down, 2 = left, 3 = right
		int generatingSlide; 
		
		int parent; //store the board that generated this one. The root will always
						//have a value of -1, indicating it has no parent
		
		//will be array of size 4 pointing to 4 possible children.
		puzzlePosition [] children;
		
		
		//a constucutor for the very first root node, which is the solution of the puzzle
		public puzzlePosition(){
			parent = -1; //the root has no parent
			level = 0; //only the first root can have level = 0. all others will be positive integer
			generatingSlide = 10; //10 just for first node. means no slide generated it
			hashValue = 123456780; //hashValue of solved position for the root.
			zeroPosition = 8; //zero is the 8th position (last position) of the hashValue integer
			children = new puzzlePosition[4];// each node will have a default of 4 possible children
											//even though the root will only have 2
		}
		
		//a constructor for generating the children
		public puzzlePosition(puzzlePosition root, int direction){
			int slidingTile = 0;   //this is the digit out of the hashCode you want to slide
			int timesToDivide = 0; //num of times you divide hashCode by 10 
								   // before you can %10 to get sliding tile
			
			level = root.level + 1; //increment the number of moves it takes to solve
			children = new puzzlePosition[4];// each node will have a default of 4 possible children
			
			// direction: 0 = tile up, 1 = tile down, 2 = tile left, 3 = tile right	
			// x is the row, y is the column
			zeroPosition = root.zeroPosition; //copy over the zeroPosition
			
			//copy the board from the root over exactly
			this.hashValue = root.hashValue;
			
			//save the slide that generated this permutation
			generatingSlide = direction; 
			
			//set the parent's child to point to this newly created node
			root.children[generatingSlide] = this;
			
			//set the child's parent to the root's hash value
			//this will be useful for finding the path back to root (solved)
			parent = root.hashValue;
			
			//switch will change the board based on direction you're dragging the tile
			switch(direction){
				case 0:
					//you want the tile to go up
					//board[x][y] = board[x+1][y];
					//board[x+1][y] = 0;
					//this is the times you should divide to get the sliding tile board[x][y]
					timesToDivide = (9 - zeroPosition - 1) -3; 
					//go ahead and divide
					slidingTile = divide(hashValue, timesToDivide);
					//now mod to get the actual value
					slidingTile %= 10;
					
					//perform the slide. first set the new 0:
					hashValue -= slidingTile * powersOfTen(timesToDivide);
					
					//now replace the old 0 with the new tile
					hashValue += slidingTile * powersOfTen(timesToDivide+3);
									
					zeroPosition += 3; //if tile went up, zero went down 1 row, increasing 3 in position
					break;
				case 1: 
					//you want the tile to go down
					//board[x][y] = board[x-1][y];
					//board[x-1][y] = 0;
					//this is the times you should divide to get the sliding tile board[x - 1][y]
					timesToDivide = (9 - zeroPosition - 1) + 3; //used to pull nonzero tile to slide
					//go ahead and divide
					slidingTile = divide(hashValue, timesToDivide);
					//now mod to get the actual value
					slidingTile %= 10;
					
					//perform the slide. first set the new 0:
					hashValue -= slidingTile * powersOfTen(timesToDivide);
					
					//now replace the old 0 with the new tile
					hashValue += slidingTile * powersOfTen(timesToDivide-3);
					
					zeroPosition -= 3; //if the tile went down, zero went up 1 row, decreasing 3 in position
					break;
				case 2: 
					//you want the tile to go left
					//board[x][y] = board[x][y+1];
					//board[x][y+1] = 0;
					//this is the times you should divide to get the sliding tile board[x][y]
					timesToDivide = (9 - zeroPosition - 1) -1; 
					//go ahead and divide
					slidingTile = divide(hashValue, timesToDivide);
					//now mod to get the actual value
					slidingTile %= 10;
					
					//perform the slide. first set the new 0:
					hashValue -= slidingTile * powersOfTen(timesToDivide);
					
					//now replace the old 0 with the new tile
					hashValue += slidingTile * powersOfTen(timesToDivide+1);
									
					zeroPosition += 1; // if tile went left, 0 went right 1, increasing in position
					break;
				case 3: 
					//you want the tile to go right
					//board[x][y] = board[x][y-1];
					//board[x][y-1] = 0;
					//this is the times you should divide to get the sliding tile board[x][y]
					timesToDivide = (9 - zeroPosition - 1) + 1; 
					//go ahead and divide
					slidingTile = divide(hashValue, timesToDivide);
					//now mod to get the actual value
					slidingTile %= 10;
					
					//perform the slide. first set the new 0:
					hashValue -= slidingTile * powersOfTen(timesToDivide);
					
					//now replace the old 0 with the new tile
					hashValue += slidingTile * powersOfTen(timesToDivide-1);
									
					zeroPosition -= 1; //if tile went right, 0 went left 1, decreasing in position
					break;
			}
			

		}
		
		
		
		//return the hash
		public int getHash(){
			return hashValue;
		}
		
		//this function divides a number by 10 a certain number of times and returns the new value
		public static int divide(int value, int timesToDivide){
			for (int i = 0; i < timesToDivide; i++){
				value = value / 10;
			}
			return value;
		}
		
		//Math.pow returns kinda slow, so I'll use this instead, since I'm only using base 10
		public static int powersOfTen(int power){
			if(power == 0)
				return 1;
			else{
				int answer = 1;
				for(int i = 0; i < power; i++){
					answer *=10;
				}
				return answer;
			}
			
		}
		
		
	}